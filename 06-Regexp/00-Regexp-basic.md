---
title: 正则表达式基础知识
linktitle: 正则表达式基础知识
toc: true
type: "docs"
date: 2019-05-05T00:00:00+01:00
draft: false
group: Regexp
---

>正则表达式验证工具： [https://regexper.com/](https://regexper.com/) 或者 [http://regexper.cn/](http://regexper.cn/)

> [正则表达式教程](https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md)

## 创建正则表达式

最简单的方式是通过字面量创建：

```js
var reg = /[a-zA-Z]/gi;
```

也可以通过 `RegExp` 构造函数来创建：

```js
var reg1 = new RegExp('a');
var reg2 = new RegExp('[a-zA-Z]', 'gi');
var reg3 = new RegExp(/[a-zA-Z]/, 'gi');
```


## 修饰符

修饰符 | 描述
--- | ---
`i` | 执行对大小写不敏感的匹配
`g` | 执行全局匹配（查找所有匹配，而非在找到第一个匹配后停止）
`m` | 执行多行匹配
`s` | 执行单行匹配

## 正则对象属性

> 属性均为只读，无法设置其值

| 属性        |  含义                 | 默认值 |
| ---         | ---                  | --- |
| `global`    | 是否全文搜索          | `false` |
| `ignoreCase` | 是否大小写敏感        | `false` |
| `multiline` | 多行搜索              | `false` |
| `lastIndex` | 是当前表达式匹配内容的最后一个字符的下一个位置| 无 |
| `source`    | 正则表达式的文本字符串  | 无 |

示例：

```js
var reg1 = /\w/;
var reg2 = /\w/gim;

console.log(reg1.global);        // false
console.log(reg1.ignoreCase);    // false
console.log(reg1.multiline);     // false
console.log(reg1.source);        // "\w"

console.log(reg2.global);        // true
console.log(reg2.ignoreCase);    // true
console.log(reg2.multiline);     // true
console.log(reg2.source);        // "\w"
```

## 方括号

| 表达式    | 描述 |
| ---       | --- |
| `[abc]` | 匹配方括号之间的任何字符 |
| `[^abc]` | 匹配任何不在方括号之间的字符 |
| `[0-9]` | 匹配任何从 0 至 9 的数字 |
| `[a-z]` | 匹配任何从小写 a 到小写 z 的字符 |
| `[A-Z]` | 匹配任何从大写 A 到大写 Z 的字符 |
| `[A-z]` | 	匹配任何从大写 A 到小写 z 的字符 |
| `[adgk]` | 匹配给定集合内的任何字符 |
| `[^adgk]` | 匹配给定集合外的任何字符 |
| `(red|blue|green)` | 	匹配任何指定的选项 |

## 子表达式

用括号括起来的正则表达式。例如：

```js
var str = 'hello world';
var reg = /(\w*)\s*(\w*)/;
var ans = str.replace(reg, '$2 $1')
console.log(ans); // world hello
```

如 `/(\w*)\s*(\w*)/` 中，第一个括号 `(\w*)` 匹配到的字符串（本例中是 `hello`），记为 `$1`，第二个括号 `(\w*)` 匹配到的字符串（本例中是 `world`），记为 `$2`。

简单地说：从左到右，以分组的左括号为标志，第一个出现的分组的序号为 1，第二个为 2，以此类推。

复杂地说：分组 0 对应整个正则表达式实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号。可以使用 `(?:exp)` 这样的语法来剥夺一个分组对组号分配的参与权。

参考：[我所认识的javascript正则表达式](https://www.cnblogs.com/zichi/p/4343009.html)

## 元字符

元字符是拥有特殊含义的字符：

| 元字符    | 描述 |
| ---       | --- |
| `.`       | 匹配除 \n 以外的任何字符（注意元字符是小数点）。 |
| `\w`      | 匹配大小写英文字符及数字 `0` 到 `9` 之间的任意一个及下划线，相当于 `[a-zA-Z0-9_]` |
| `\W`      | 不匹配大小写英文字符及数字 `0` 到 `9` 之间的任意一个，相当于 `[^a-zA-Z0-9_]` |
| `\s`      | 匹配任何空白字符，相当于 `[ \f\n\r\t\v]` |
| `\S`      | 匹配任何非空白字符，相当于 `[^\s]` |
| `\b`      | 匹配单词边界 |
| `\B`      | 匹配非单词边界 |
| `\d`      | 匹配任何 `0` 到 `9` 之间的单个数字，相当于 `[0-9]` |
| `\D`      | 不匹配任何 `0` 到 `9` 之间的单个数字，相当于 `[^0-9]` |
| `[\u4e00-\u9fa5]` | 匹配任意单个汉字（这里用的是 `Unicode` 编码表示汉字的 ) |

助记：
+ w: word
+ s: space
+ d: digit

## 量词（限定符）

上面的元字符都是针对单个字符匹配的，要想同时匹配多个字符的话，还需要借助限定符。

下面是一些常见的限定符 ( 下表中 `n` 和 `m` 都是表示整数，并且 `0 < n < m`) ： 

| 限定符  | 描述                                 |
| ---     | ---                                  |
| `{n}`   | 匹配 `n` 个元字符                    |
| `{n,}`  | 匹配至少 `n` 个元字符                |
| `{n,m}` | 匹配 `n` 到 `m` 个元字符             |
| `*`     | 匹配 0 到多个元字符，相当于 `{0,}`   |
| `?`     | 匹配 0 到 1 个元字符，相当于 `{0,1}` |
| `+`     | 匹配至少 1 个元字符，相当于 `{1,}`   |
| `^`     | 字符串必须以指定的字符开始           |
| `$`     | 字符串必须以指定的字符结束           |

## 其他
1. 由于在正则表达式中`\`、`?`、`*`、`^`、`$`、`+`、`(`、`)`、`|`、`{`、`[`等字符已经具有一定特殊意义，如果需要用它们的原始意义，则应该对它进行转义，例如希望在字符串中至少有一个“ \ ”，那么正则表达式应该这么写： `\\+` 。

2. 可以将多个元字符或者原义文本字符用括号括起来形成一个分组，比如 `^(13)[4-9]\d{8}$` 表示任意以 `13` 开头的移动手机号码。

3. 另外对于中文字符的匹配是采用其对应的 `Unicode` 编码来匹配的，对于单个 `Unicode` 字符，如 `\u4e00` 表示汉字“一”， `\u9fa5`  表示汉字“龥”，在 `Unicode` 编码中这分别是所能表示的汉字的第一个和最后一个的 `Unicode` 编码，在 `Unicode` 编码中能表示 20901 个汉字。

4. 关于 `\b` 的用法，它代表单词的开始或者结尾，以字符串 `123a 345b 456 789d` 作为示例字符串，如果正则表达式是 `\b\d{3}\b`，则仅能匹配 `456` 。

5. 可以使用 `|` 来表示或的关系，例如 `[z|j|q]` 表示匹配 `z` 、 `j` 、 `q` 之中的任意一个字母。

6. 正则验证工具： [https://regexper.com/](https://regexper.com/) 或者 [http://regexper.cn/](http://regexper.cn/)
